1.AuthenticationFilter:- Intercepts the request and Gives to AuthManage.
2.AuthenticationManager:- Keeps track of Authprovider and gives request to it.
3.AuthenticationProvder:- This is the component that actually holds logic for
	authentiation i.e the checking logic is here.It uses 4 and 5 below for some help.
4.UserDetailsService:- this is used by AuthenticationProvider to fetch the 
	UserDetails Object by the Username that came in the request.
5. PasswordEncoder:- This is ued to encrpty the password that came with request and 
	comparing the available password in our Reporsitry.
	
	Above Five are most imp high level componets that manage spring security .
	
6.UserDetailsManager :-Extends the USerDetailsService Contract. Provide functionality of Managing UserDetails Objects 
	such as adding,deleting, Modifying.
	
	****All above are interfaces / contracts when we use concrete sub classes to iNstatiate 
	they gets used to perform actual operations.So spring has just coupled the interface
	references and the actual working depends n which objects you bind to those references.
	****
7. UserDetails:- this is the interface which spring recognizes as User Entity.
	so you put your data using it so that framework will understand it.

8. GrantedAUthority:- This Interface is what spring recognizes as an action that a user
	is allowed to do. SO we can associates a set of authorities with a user using List of GrantedUAthorities.
	***Spring Enforces tat a user must have at least authority even if you don't want 
	it or may not use it.

<--------------------**---------------------->
<->UserDetails interface
has methods to get username,credentials,authorities and 4 method to work with some 
useful properties such as locking,expiring,etc.

<->GrantedAUthorities
It just has a single method "STring getAUthority();" i.r just a name for authiority is sufficint
for it to be used; Later you can difeing specific Rules that user can do and assoicaite thme
with the name you have given.

** //Using Lambda expr:- can be used as it has only one abstract method.
	GrantedAuthority g1= () -> "READ";
	
	//Spring defined basic subclass that implements GrantedAUthority
	GrantedAuthority g2= new SimpleGrantedAuthority("READ");
**

<New Content>
this example has a setup of fetching User Data from RDBMS an dcreate jpa entities using JpaUser
which is being given JdbcUserDetails and which connects it with InMomeoryUserDetailsManager from @Bean method 
in UserMgmtConfig class .

<->UserDetailsService :- The component which used by the AUthenication Provider to fetch the
	UserDetaisl Object based on the username provide to it.
	It contains only 1 method"UserDetails loadByUserName(String username)".
	if user doesn't exist it throws UsernameNotFoundException which is a RunTimeException.
	
	Check the CustomInMemoryUserDetailsService which is creating a list of CustomUserDetails
	in the memory..and the loadByUsername method searches thorugh the list of users.
   	
This Project is excluding the DataSourceAutocconfig.class as we have passed  in the @SpringBootApplication annotation.

<NewContent>
<->UserDetailsManager:- interface that extends UserDetailsService. This just adds few methods that allows
you directly handle the UserManagement activities, such as addition,deletion,modification.
 
Spring provides several implementations of these such as InMemoryUserDetailsManage and JdbcUserDetailsManager.

When the User is authenticated Successfully the details are updated in the Security Context by the Authentication filter.

<->JdbcUserDetailsManager:- allows user manangement whatever RDBMS you configure it with;

Expects two Tables from Users(username,password,enabled) and authorities
Please refer to the @Bean provided in USerMgmtConfig, i have given two specefic quries to
fetch userdeata and the authorities from MySql tables;

<->New Content

<->PasswordEncoder:- Responsibility of managing and Validating password .
two abstract methods :- String encode(CharSequence rawPasswd) and boolean matches(CharSequence raw, String encoded)  
encode is used at start to get hashed reprsentation while matches is used by authProvider to check if incoming msg is same 
as encoded passwords 

Theres one more method upgradeEncoding which by deafult returns false but if set to true
then the encoded password is again encoded to better security.

Spring provides some implementations for the PassWord enoder one of which is NoOpPasswordEncoder which just simply stores the passwords
as plain text.
so the methods would look like something as follows:-
	encode(raw){ return raw.toString()}
	matches(raw,encoded) {return raw.equals(encoded)}
Theress basically what we say is the encoding is same a password itself.
but in this example we'll implement our own
check encoders.Sha512PasswordEncoder;	

<->StandardPasswordEncoder:- Used Sha256 to encode. deperecated now as we don't consider to strong enough anymore.
<->Pbkdf2PasswordEncoder:- Uses password-based key derivation function 2.
<->BcryptPasswordEncoder:- Uses a bcrypt strong hashing function to encode the password
<->ScryptPasswordEncoder:- Uses an scrypt hashing function to encode.
check @Bean Password encoder for exmples.

<-> New Content
What if you find a problem with password encoder algo you use currently adn you now change the
algorith for new users...but don't want to update the existing users password ..so how do you invoke correct password
encoder during authentication....DelegatingPasswordEncoder is the answer.
The hash starts with the name of algorith so based on that it invokes crrect password encoder .
It maintains  a map of key values where value is the reference to the specific password encoder.
For examplle refer @Bean delgatingPassEncoder() in userMgmtConfig.  
You can define your own map  or use the Delegatingpassword encoder given by Sprinng itself.



<->New Content
The SPing provides a default authetication implementaion which revolves around Username and Password.
in real world you may need additional steps suchas sms or email otp,additional keys from file,etc.
SO Spring security uses Authentication Provider to implement teh authentication flow
which involves username password...
You can write your own custom flow y implemting the authentication provider interface.

<->Auhentication Interface:- Reprsents the authentication request itself which holds the details of entity requesting authentication.
The user requesting access to the application is Called as Principal.
SO this Authentication i/f extedns the Principal i/f.

 Principal i/f:- only getName() method:- Available in core java.security api. someonw who's requesting access at least must have a name i.e
 the identifier used to identify it which may be id,username,etc.
 
 Authentication I/f extends Principal:-
 	@Override getName():- Id of user
 	getCredentials():- user must have a secret:- password,code,fingerprint,etc. 
 	getAuthorities():- set of privileges for user:- must have at least 1 privilage.
 	getDetails():- Any additional info related to user provided here
 	isAuthenticated():- status of the authentication Object.
 	
 check config.CustomAUtenticationProvider for example and details. 
 
 <New-Content>:- SecurityContext is the object which holds the succesfully Authenticated Authentication
 instance.
 After Successful authentication AUthentication Provider return to Auth Manager which gives the AUthentication Object to Authentication
 Filter,
 Auth Filtersores the object in Secuirty Context and Gives the request Object to Controller.
 SecurityContext-i/f:- is has to methods setAuthentication, getAUthentication.
 
 How Security Context is Managed?:
 SecurityContextHolder is the Manager Object. It has 3 strategies to manage the Seurity ontext.
 	1.MODE_THREADLOCAL:- each thread stores it's own detils in security context. In thread-per request this is 
 	a commonly used.Each request has an indivisual thread
 	2.MODE_INHERITABLETHREADLOCAL:- same as above. but also instructs spring to copy context to next thread in case of asynchronous method.
 	which means a thread running with @async method inehrits the context.
 	3.MODE_GLOBAL:- ALl the treads of application sees the Same Security Context Instance.
 	
 	visit controller.DefController. "/secconfig" GetMapping.
 
 
 <New - Content>
 How to share security context to threads that are crated by us and Spring is unaware of them...
 DelegatingSecurityContextRunnable, DelegatingSecurityContextCallable can be uesd to decorate
 our asynchrnous Task and they will be resposible to provide security context details.
 
 
 There is a better way ..rather than managing propogation from a Task we can manage it from Thread Pool Itself.
 

<-New Conenet>
Using AUthenticatioEntryPoint we can customize the Response that gets sent out on
Authentication failure;
see CustomAuthEntryPoint class for example. 




